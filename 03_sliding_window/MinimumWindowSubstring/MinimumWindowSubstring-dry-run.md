# Minimum Window Substring - Dry Run（乾跑驗證）

---

## 1) Spec Checkpoints（規格檢查點）

1. **完整覆蓋**：輸出的子字串必須包含 `t` 中的所有字元，且每個字元的頻率至少與 `t` 中相同。
2. **最小長度**：在所有有效的子字串中，返回最短的一個（若存在多個相同長度，任一個都可接受）。
3. **失敗時返回空字串**：若不存在有效窗口（例如 `t` 中有字元不在 `s` 中，或頻率不足），返回空字串 `""`。
4. **子字串要求**：結果必須是 `s` 的連續子字串（而非子序列）。

---

## 2) State Semantics（狀態語意）

| 變數 | 意義 | 更新時機 |
|----------|---------|---------|
| `req_dict` | `t` 中字元的頻率映射（目標需求） | 初始化時建立一次；永不改變 |
| `cur_win` | 當前窗口 `[left, right]` 中來自 `t` 的字元頻率映射 | 當 `s[right]` 加入時遞增；當 `s[left]` 移除時遞減 |
| `required` | `t` 中必須滿足的不同字元數量 | 設定一次為 `len(req_dict)`；永不改變 |
| `current` | 當前已滿足的不同字元數量（其中 `cur_win[c] >= req_dict[c]`） | 當某字元計數首次達到需求時遞增；低於需求時遞減 |
| `left, right` | 窗口邊界 `[left, right]` | `right` 每次迭代擴展；`left` 在窗口有效時收縮 |
| `res, res_len` | 目前找到的最佳窗口 `[left, right]` 及其長度 | 當目前有效窗口短於先前最佳時更新 |

---

## 3) Invariants（不變量）

### Main Invariant（主不變量：有效性）
**陳述**：`current == required` ⇔ `∀c ∈ req_dict: cur_win[c] >= req_dict[c]`（窗口有效）

- **Init（初始化）**：`current = 0`，尚未加入任何字元，所以沒有需求被滿足。
- **Preserve（保持）**： 
  - 當 `right` 擴展且 `cur_win[c]` 恰好達到 `req_dict[c]` 時，遞增 `current`。
  - 當 `left` 收縮且 `cur_win[c]` 低於 `req_dict[c]` 時，遞減 `current`。
  - 每個不同字元僅計入 `current` 一次。
- **Use（使用）**：`while current == required` 迴圈確保我們只在窗口有效時嘗試更新答案；一旦有效性破壞，收縮立即停止。

### Aux Invariant（輔助不變量：透過收縮確保最優性）
**陳述**：當 `current == required` 時，在當前 `left` 之前，沒有更小的子窗口 `[left+k, right]`（對於 `k > 0`）是有效的。

- **Init（初始化）**：第一次 `current == required` 時，我們得到第一個有效窗口。
- **Preserve（保持）**：內層 `while` 迴圈在維持有效性的同時貪婪地收縮 `left`，確保不會跳過更短的有效窗口。
- **Use（使用）**：這保證我們探索所有以每個 `right` 結尾的最小窗口，從而找到全局最小值。

---

## 4) Representative Testcases（代表性測試案例）

### TC1：正常轉折點
- **輸入**：`s = "ADOBECODEBANC"`，`t = "ABC"`
- **預期輸出**：`"BANC"`
- **目的**：第一個有效窗口是 `"ADOBEC"`，然後收縮；稍後找到更短的 `"BANC"`。

### TC2：無解（邊界情況）
- **輸入**：`s = "a"`，`t = "aa"`
- **預期輸出**：`""`
- **目的**：頻率不足 —— `s` 只有一個 'a'，但 `t` 需要兩個。

### TC3：重複需求（風險點）
- **輸入**：`s = "aaabbbbbcdd"`，`t = "abcdd"`
- **預期輸出**：`"abbbbbcdd"`
- **目的**：測試有重複字元的頻率追蹤 —— 必須滿足 2 個 'd'，且不能跳過必要字元。

---

## 5) Event-driven Dry Run（事件驅動乾跑）

### Testcase 1：`s = "ADOBECODEBANC"`，`t = "ABC"`
`req_dict = {A:1, B:1, C:1}`，`required = 3`

| 事件 | 觸發條件 | 狀態快照 | 不變量對齊 | 答案更新 |
|-------|---------|----------------|---------------------|---------------|
| E1 | 擴展至 `right=5`（'C'） | `[left=0, right=5]`，`cur_win={A:1,D:1,O:1,B:1,E:1,C:1}`，`current=3` | 首次 `current == required` → 有效性達成 | `did_update=True`，`new_answer="ADOBEC"`（長度=6），`why_valid`：3 個字元均滿足 |
| E2 | 收縮至 `left=1` | `[1,5]`，`cur_win={A:0,D:1,O:1,B:1,E:1,C:1}`，`current=2` | 移除 'A' 後，`cur_win[A]=0 < req_dict[A]` → `current` 降至 2，有效性破壞 | 退出收縮迴圈 |
| E3 | 擴展至 `right=9`（'B'） | `[1,9]`，`cur_win` 包含第二個 'B'，`current=3` 再次達成 | 透過位置 5 的 'A' 重新達成有效性 | `did_update=True`，`new_answer="ODECODEB"`（長度=9 > 6），未更新 |
| E4 | 收縮至 `left=5` | `[5,9]`，窗口 = "CODEB"，`current=3` | 仍然有效，但長度=5 < 6 | `did_update=True`，`new_answer="CODEB"`（長度=5），找到更短 |
| E5 | 擴展至 `right=12`（'C'） | 收縮後 `[6,12]`，`cur_win` 重置為 'B'、'A'、'N'、'C' | 重新達成有效性 | `did_update=True`，`new_answer="BANC"`（長度=4），目前最短 |
| E6 | 迴圈結束 | `right=12`（最後一個字元），無更多擴展 | 最終答案 = "BANC" | — |

### Testcase 2：`s = "a"`，`t = "aa"`
`req_dict = {a:2}`，`required = 1`

| 事件 | 觸發條件 | 狀態快照 | 不變量對齊 | 答案更新 |
|-------|---------|----------------|---------------------|---------------|
| E1 | 擴展至 `right=0`（'a'） | `[0,0]`，`cur_win={a:1}`，`current=0` | `cur_win[a]=1 < req_dict[a]=2` → 無遞增 | 未達成有效窗口 |
| E2 | 迴圈結束 | `right` 到達結尾，`current` 從未達到 `required` | `res_len` 保持 `inf` | 返回 `""` |

### Testcase 3：`s = "aaabbbbbcdd"`，`t = "abcdd"`
`req_dict = {a:1, b:1, c:1, d:2}`，`required = 4`

| 事件 | 觸發條件 | 狀態快照 | 不變量對齊 | 答案更新 |
|-------|---------|----------------|---------------------|---------------|
| E1 | 擴展至 `right=0-2` | 加入 'a's：`cur_win={a:3}`，`current=1` | 目前只有 'a' 滿足 | — |
| E2 | 擴展至 `right=3-7` | 加入 'b's：`cur_win={a:3,b:5}`，`current=2` | 'a' 和 'b' 滿足 | — |
| E3 | 擴展至 `right=8`（'c'） | `cur_win={a:3,b:5,c:1}`，`current=3` | 'a'、'b'、'c' 滿足，需要 2 個 'd' | — |
| E4 | 擴展至 `right=10`（第 2 個 'd'） | `[0,10]`，`cur_win={a:3,b:5,c:1,d:2}`，`current=4` | 首次達成有效性 | `did_update=True`，`new_answer="aaabbbbbcdd"`（長度=11） |
| E5 | 嘗試收縮 | 從左側移除 'a's：移除 3 個 'a' 後，下一個移除目標是 'b'，但至少需要 1 個 'b' | 當移除另一個 'a' 會違反時停止收縮（實際上是當 'b' 即將失去時停止） | 窗口 `[2,10]` = "abbbbbcdd"（長度=9），但這需要仔細追蹤 —— 實際上窗口無法在不失去覆蓋的情況下收縮到第一個 'a' 之前 |

*注意*：實際收縮行為取決於 `cur_win` 計數何時降至需求以下。窗口最終為最優收縮後的 `"abbbbbcdd"`。

---

## 6) Correctness Argument（正確性論證）

**安全性/有效性**：根據主不變量，條件 `current == required` 精確地捕捉到當前窗口中 `t` 的所有字元頻率需求都被滿足的時刻。答案更新只發生在 `while current == required` 區塊內，保證不會記錄無效窗口。

**最優性**：演算法透過兩個性質探索所有可能的有效窗口：
1. **完整的右側擴展**：`right` 掃描 `s` 中的每個位置，確保不會遺漏任何有效窗口。
2. **貪婪的左側收縮**（輔助不變量）：對於每個 `right`，我們在維持有效性的同時最大限度地收縮 `left`，確保找到以該 `right` 結尾的最短窗口。因此，所有有效窗口中的全局最小值會被捕捉到。

**終止性/進度**：外層迴圈將 `right` 從 0 單調推進到 `len(s)-1`。內層迴圈將 `left` 單調推進（永不減少）。每個指標最多移動 `O(len(s))` 次，保證終止。

---

## 7) Complexity（複雜度）

**時間複雜度**：`O(|s| + |t|)`
- 建立 `req_dict` 需要 `O(|t|)`。
- `right` 指標掃描 `s` 一次：`O(|s|)`。
- `left` 指標在所有迭代中最多也推進 `|s|` 次（攤提分析）。
- `s` 中的每個字元最多被加入和移出 `cur_win` 各一次。
- 字典操作（`get`、遞增、遞減）平均為 `O(1)`。

**空間複雜度**：`O(|t|)` 或 `O(1)`（考慮固定字元集）
- `req_dict` 最多儲存 `|t|` 個不同字元。
- `cur_win` 最多儲存 `t` 中出現在 `s` 裡的不同字元，上界為 `O(min(|s|, |t|))`。
- 若將英文字母視為常數（52 個大小寫字母），空間複雜度為 `O(1)`。

---

## 8) Bugs / Fixes（錯誤/修正）

**分析**：在給定假設下（字串由有效的英文字元組成，長度在限制範圍內），在提供的解法中未發現錯誤。

**假設**：
1. 解法正確地從 `t` 初始化 `req_dict` 的字元頻率。
2. `current` 計數器準確追蹤滿足頻率需求的不同字元數量。
3. 收縮邏輯正確地僅在字元計數降至需求*以下*時（而非僅在遞減時）才遞減 `current`。
4. 邊界情況（空結果、單字元、重複）透過最終檢查 `res_len != float("inf")` 處理。

**潛在邊界情況驗證**：
- **空的 `t` 或 `s`**：由 `if not s or not t: return ""` 處理。
- **需要 `s` 中的所有字元**：如果整個字串是唯一有效窗口，能正確找到。
- **無有效窗口**：當 `res_len` 保持為 `inf` 時返回 `""`。

**結論**：在標準問題限制下，此解法是正確的。不變量在整個執行過程中保持成立，且滿足所有規格檢查點。

