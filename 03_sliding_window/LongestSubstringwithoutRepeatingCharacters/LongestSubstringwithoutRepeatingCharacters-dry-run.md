# Longest Substring without Repeating Characters - Dry Run（乾跑驗證）

---

## 1) Spec Checkpoints（規格檢查點）

1. **無重複性**：返回的子字串長度對應的實際子字串中，不得有任何字元重複出現。
2. **最長性**：在所有無重複子字串中，返回最長的長度（若有多個相同長度，返回任一長度即可）。
3. **連續性**：必須是連續子字串，而非子序列。
4. **邊界處理**：空字串返回 0；單字元字串返回 1。

---

## 2) State Semantics（狀態語意）

| 變數 | 意義 | 更新時機 |
|----------|---------|---------|
| `seen` | 字典，記錄每個字元最後一次出現的索引位置 | 每次 `end` 擴展時更新 `seen[c] = end` |
| `start` | 當前無重複窗口的左邊界索引 | 當遇到重複字元且其上次位置 `>= start` 時，跳躍至 `seen[c] + 1` |
| `end` | 當前掃描的右邊界索引（包含） | 每次迭代後遞增 `end += 1` |
| `max_len` | 目前找到的最長無重複子字串長度 | 當 `curr_len = end - start + 1 > max_len` 時更新 |
| `curr_len` | 當前窗口 `[start, end]` 的長度 | 每次迭代計算 `end - start + 1` |

---

## 3) Invariants（不變量）

### Main Invariant（主不變量：窗口無重複性）
**陳述**：在任意時刻，窗口 `[start, end]` 內的所有字元都不重複，即 `∀i, j ∈ [start, end], i ≠ j ⇒ input_str[i] ≠ input_str[j]`。

- **Init（初始化）**：`start = 0, end = 0`，窗口包含最多一個字元，自然無重複。
- **Preserve（保持）**：
  - 當 `end` 擴展且 `input_str[end]` 未在當前窗口中出現過（即 `c not in seen` 或 `seen[c] < start`），窗口仍無重複。
  - 當 `input_str[end]` 在當前窗口中出現過（`seen[c] >= start`），立即將 `start` 跳至 `seen[c] + 1`，排除重複字元，恢復無重複性。
- **Use（使用）**：每次更新 `max_len` 時，保證當前窗口是無重複的，因此記錄的長度是有效的。

### Aux Invariant（輔助不變量：最優性追蹤）
**陳述**：`max_len` 始終記錄從開始到當前位置所有探索過的無重複窗口的最大長度。

- **Init（初始化）**：`max_len = 0`，尚未探索任何窗口。
- **Preserve（保持）**：每次計算 `curr_len` 後，若大於 `max_len` 則更新；否則保持不變。
- **Use（使用）**：循環結束時，`max_len` 即為全局最長無重複子字串長度。

---

## 4) Representative Testcases（代表性測試案例）

### TC1：正常轉折點（重複後跳躍）
- **輸入**：`input_str = "abcabcbb"`
- **預期輸出**：`3`（對應 `"abc"`）
- **目的**：測試遇到重複字元時，`start` 正確跳躍，並在多次重複中維持最大長度。

### TC2：邊界情況（所有字元相同）
- **輸入**：`input_str = "bbbbb"`
- **預期輸出**：`1`（對應 `"b"`）
- **目的**：測試連續重複字元，每次 `start` 都需要跳躍，最長長度始終為 1。

### TC3：風險點（重複字元在舊窗口外）
- **輸入**：`input_str = "abba"`
- **預期輸出**：`2`（對應 `"ab"` 或 `"ba"`）
- **目的**：測試當重複字元的上次位置已不在當前窗口內（`seen[c] < start`）時，不應跳躍 `start`。

---

## 5) Event-driven Dry Run（事件驅動乾跑）

### Testcase 1：`input_str = "abcabcbb"`

| 事件 | 觸發條件 | 狀態快照 | 不變量對齊 | 答案更新 |
|-------|---------|----------------|---------------------|---------------|
| E1 | `end=0`，加入 'a' | `[start=0, end=0]`，`seen={a:0}`，`curr_len=1` | 首字元，窗口無重複 | `max_len=1` |
| E2 | `end=1-2`，加入 'b', 'c' | `[0,2]`，`seen={a:0,b:1,c:2}`，`curr_len=3` | 連續無重複擴展 | `max_len=3` |
| E3 | `end=3`，加入 'a'（重複） | `seen[a]=0 >= start=0` → 重複檢測，`start` 跳至 `0+1=1` | 移除舊 'a'，恢復無重複 | `[1,3]`，`curr_len=3`，`max_len` 保持 3 |
| E4 | `end=4`，加入 'b'（重複） | `seen[b]=1 >= start=1` → 重複檢測，`start` 跳至 `1+1=2` | 移除舊 'b'，恢復無重複 | `[2,4]`，`curr_len=3`，`max_len` 保持 3 |
| E5 | `end=5`，加入 'c'（重複） | `seen[c]=2 >= start=2` → 重複檢測，`start` 跳至 `2+1=3` | 移除舊 'c'，恢復無重複 | `[3,5]`，`curr_len=3`，`max_len` 保持 3 |
| E6 | `end=6-7`，連續加入 'b'（重複） | 每次 'b' 重複，`start` 持續右移 | 窗口收縮至長度 1 | 最終 `max_len=3` |

### Testcase 2：`input_str = "bbbbb"`

| 事件 | 觸發條件 | 狀態快照 | 不變量對齊 | 答案更新 |
|-------|---------|----------------|---------------------|---------------|
| E1 | `end=0`，加入 'b' | `[0,0]`，`seen={b:0}`，`curr_len=1` | 首字元無重複 | `max_len=1` |
| E2 | `end=1`，加入 'b'（重複） | `seen[b]=0 >= start=0` → `start=1` | 跳過舊 'b'，窗口 `[1,1]` | `curr_len=1`，`max_len` 保持 1 |
| E3 | `end=2-4`，持續重複 | 每次 `start` 跟隨 `end`，窗口長度始終為 1 | 所有窗口長度 1，無重複維持 | 最終 `max_len=1` |

### Testcase 3：`input_str = "abba"`

| 事件 | 觸發條件 | 狀態快照 | 不變量對齊 | 答案更新 |
|-------|---------|----------------|---------------------|---------------|
| E1 | `end=0-1`，加入 'a', 'b' | `[0,1]`，`seen={a:0,b:1}`，`curr_len=2` | 無重複 | `max_len=2` |
| E2 | `end=2`，加入 'b'（重複） | `seen[b]=1 >= start=0` → `start=2` | 跳至第二個 'b'，移除 'a' 和第一個 'b' | `[2,2]`，`curr_len=1`，`max_len` 保持 2 |
| E3 | `end=3`，加入 'a' | `seen[a]=0 < start=2` → 不視為重複 | 'a' 上次位置在舊窗口外，安全加入 | `[2,3]`，`seen={a:3,b:2}`，`curr_len=2`，`max_len` 保持 2 |

*注意*：TC3 展示了關鍵邏輯：只有當 `seen[c] >= start` 時才視為重複，避免誤判舊窗口外的字元。

---

## 6) Correctness Argument（正確性論證）

**安全性/有效性**：根據主不變量，窗口 `[start, end]` 在任意時刻都維持無重複性。每當檢測到重複字元（`seen[c] >= start`），立即將 `start` 跳至重複位置之後（`seen[c] + 1`），確保新窗口排除了導致重複的舊字元。因此，所有記錄的 `max_len` 都對應有效的無重複子字串。

**最優性**：演算法探索所有可能的無重複子字串：
1. **完整掃描**：`end` 從 0 掃描到 `len(input_str) - 1`，保證每個位置都作為右邊界被考慮。
2. **最大化窗口**：在不違反無重複性的前提下，`start` 僅在必要時移動（遇到重複），因此對於每個 `end`，窗口 `[start, end]` 是以該 `end` 結尾的最長無重複子字串。
3. **全局最大**：透過持續更新 `max_len`，捕捉所有階段的最大值。

**終止性/進度**：外層 `while end < len(input_str)` 循環中，`end` 每次遞增 1，最多執行 `len(input_str)` 次，保證終止。`start` 只會增加，不會減少，且 `start <= end + 1`，不會造成無限循環。

---

## 7) Complexity（複雜度）

**時間複雜度**：`O(n)`，其中 `n = len(input_str)`
- `end` 指標掃描整個字串一次：`O(n)`。
- `start` 指標最多也移動 `n` 次（攤提分析：每個字元最多被訪問兩次，一次由 `end`，一次被 `start` 跳過）。
- 字典操作（查詢 `c in seen`、更新 `seen[c]`）平均為 `O(1)`。
- 總時間為 `O(n)`。

**空間複雜度**：`O(min(n, m))`，其中 `m` 為字元集大小
- `seen` 字典最多儲存字串中出現過的所有不同字元，上界為 `O(n)`。
- 若字元集固定（如 ASCII 128 個字元），則空間為 `O(m) = O(1)`。
- 實際上，`seen` 的大小受限於字串長度和字元集大小中的較小者。

---

## 8) Bugs / Fixes（錯誤/修正）

**分析**：在給定假設下（字串為有效字元組成，長度在合理範圍內），在提供的解法中未發現錯誤。

**假設**：
1. 解法正確地處理空字串，提前返回 0。
2. `seen` 字典正確記錄字元最後出現位置，且在每次迭代中更新。
3. 重複檢測條件 `seen[c] >= start` 正確區分「當前窗口內的重複」與「舊窗口外的字元重現」。
4. `start` 的跳躍邏輯 `start = seen[c] + 1` 確保新窗口排除導致重複的字元。

**潛在邊界情況驗證**：
- **空字串**：由 `if not input_str: return 0` 正確處理。
- **單字元**：`end=0` 時，`curr_len=1`，`max_len=1`，正確返回。
- **所有字元相同**：每次 `start` 跟隨 `end`，`max_len=1`，正確。
- **無重複字元**：`start` 始終為 0，`max_len` 等於字串長度，正確。
- **重複字元在舊窗口外**：條件 `seen[c] >= start` 確保不誤判，正確。

**結論**：此解法在標準問題限制下是正確的。不變量在整個執行過程中保持成立，所有規格檢查點均得到滿足。特別是對「重複」的定義（僅限當前窗口內）處理精確，避免了常見的邊界錯誤。
