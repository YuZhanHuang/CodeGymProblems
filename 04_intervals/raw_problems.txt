Interval List Intersections

Statement

For two lists of closed intervals given as input, interval_list_a and interval_list_b, where each interval has its own start and end time, write a function that returns the intersection of the two interval lists.

For example, the intersection of [3, 8] and [5, 10] is [5, 8].

Constraints

0 ≤ interval_list_a.length, interval_list_b.length ≤ 1000

0 ≤ start[i] < end[i] ≤ 10^9, where i is used to indicate interval_list_a

end[i] < start[i + 1]

0 ≤ start[j] < end[j] ≤ 10^9, where j is used to indicate interval_list_b

end[j] < start[j + 1]


def intervals_intersection(interval_list_a, interval_list_b):
    i, j = 0, 0
    ans: List[List[int]] = []
    
    # 同時掃描兩個列表
    while i < len(interval_list_a) and j < len(interval_list_b):
        a_start, a_end = interval_list_a[i]
        b_start, b_end = interval_list_b[j]
        
        # 計算可能的重疊區間
        start = max(a_start, b_start)
        end   = min(a_end, b_end)
        if start <= end:
            ans.append([start, end])
        
        # 推動結束得較早的那個指標
        if a_end < b_end:
            i += 1
        else:
            j += 1
    
    return ans


Merge Intervals

Statement

We are given an array of closed intervals, intervals, where each interval has a start time and an end time. The input array is sorted with respect to the start times of each interval. For example, intervals = [[1,4], [3,6], [7,9]] is sorted in terms of start times 1, 3, and 7.

Your task is to merge the overlapping intervals and return a new output array consisting of only the non-overlapping intervals.


Constraints

1 ≤ intervals.length ≤ $10^{4}$

intervals[i].length = 2

0 ≤ start time ≤ end time ≤ $10^{4}$

def merge_intervals(intervals):
    result = [intervals[0][:]]
    for start, end in intervals[1:]:
        last_start, last_end = result[-1]
        if start <= last_end:
            result[-1][1] = max(last_end, end)
        else:
            result.append([start, end])
    
    return result

Insert Interval


Statement

Given a sorted list of non overlapping intervals and a new interval, your task is to insert the new interval into the correct position while ensuring that the resulting list of intervals remains sorted and non overlapping. Each interval is a pair of nonnegative numbers, the first being the start time and the second being the end time of the interval.

https://leetcode.com/problems/insert-interval/description/

Example 1:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Constraints

0 ≤ existing_intervals.length ≤ $10^{4}$

existing_intervals[i].length, new_interval.length == 2

0 ≤ start time, end time ≤ $10^{4}$

The first number should always be less than the second number in each interval.

The list of intervals is sorted in ascending order based on the first element in every interval.


def insert_interval(intervals, new_interval):
    new_start, new_end = new_interval
    output = []
    inserted = False

    for cur_start, cur_end in intervals:
        if cur_end < new_start:
            # this interval is completely before new_interval
            output.append([cur_start, cur_end])

        elif cur_start > new_end:
            # this interval is completely after new_interval—
            # if we haven't yet inserted new_interval, do it now:
            if not inserted:
                output.append([new_start, new_end])
                inserted = True
            output.append([cur_start, cur_end])

        else:
            # overlapping: extend the new_interval to cover it
            new_start = min(new_start, cur_start)
            new_end   = max(new_end,   cur_end)

    # if new_interval goes at the very end
    if not inserted:
        output.append([new_start, new_end])

    return output


Task Scheduler


Statement

We’re given a character array, tasks, where each character represents a unique task. These tasks need to be performed by a single CPU, with each task taking one unit of time. The tasks can be performed in any order. At any given time, a CPU can either perform some task or stay idle.

For the given tasks, we are also provided with a positive integer value, n, which represents the cooling period between any two identical tasks. This means that the CPU must wait for at least n units of time before it performs the same task again. For example, if we have the tasks [A,B,A,C] and n = 2, then after performing the first A task, the CPU will wait for at least 2 units of time to perform the second A task. During these 2 units of time, the CPU can either perform some other task or stay idle.

Given the two input values, tasks and n, find the least number of units of time the CPU will take to perform the given tasks.

https://leetcode.com/problems/task-scheduler/description/Example 1:

Input: tasks = ["A","A","A","B","B","B"], n = 2

Output: 8

Explanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.

Constraints

1 <= tasks.length <= 10000

tasks consists of uppercase English letters.

0 <= n

def least_time(tasks, n):
    frq = {}
    for task in tasks:
        frq[task] = 1 + frq.get(task, 0)

    frq = dict(sorted(frq.items(), key=lambda x: x[1]))
    max_frq = frq.popitem()[1]
    idle = (max_frq - 1) * n

    while frq and idle > 0:
        idle -= min(max_frq - 1, frq.popitem()[1])
    
    idle = max(0, idle)

    return len(tasks) + idle


from heapq import *


def least_interval(tasks, n):
    frq = {}
    max_heap = []

    for task in tasks:
        frq[task] = 1 + frq.get(task, 0)

    for key, val in frq.items():
        heappush(max_heap, (-val, key))

    max_frq, _ = heappop(max_heap)
    max_frq = -max_frq

    idle = (max_frq - 1) * n

    while max_heap and idle > 0:
        nxt_max_frq, _ = heappop(max_heap)
        nxt_max_frq = -nxt_max_frq
        idle -= min(max_frq - 1, nxt_max_frq)
    
    idle = max(0, idle)

    return len(tasks) + idle

Employee Free Time

Statement

You’re given a list containing the schedules of multiple employees. Each person’s schedule is a list of non-overlapping intervals in sorted order. An interval is specified with the start and end time, both being positive integers. Your task is to find the list of finite intervals representing the free time for all the employees.

Note: The common free intervals are calculated between the earliest start time and the latest end time of all meetings across all employees.

https://leetcode.com/problems/employee-free-time/description/

Constraints:

1 ≤ schedule.length , schedule[i].length ≤ 50

0 ≤ interval.start < interval.end ≤ 10**8, where interval is any interval in the list of schedules.

from interval import Interval
from heapq import heappush, heappop


def employee_free_time(schedule):  
    min_heap = []
    result = []

    for idx, member in enumerate(schedule):
        heappush(min_heap, (member[0].start, idx, 0))
        
    prev = min_heap[0][0]

    while min_heap:
        _, i, j = heappop(min_heap)
        interval = schedule[i][j]
        if interval.start > prev:
            result.append(Interval(prev, interval.start))

        prev = max(prev, interval.end)
        check_idx = len(schedule[i]) - 1  # 最大 index 

        if j+1 <= check_idx:
            interval = schedule[i][j+1]
            heappush(min_heap, (interval.start, i, j+1))

    return result


Count Days Without Meetings

Statement

You are given a positive integer, days, which represents the total number of days an employee is available for work, starting from day 11. You are also given a 2D array, meetings, where each entry meetings[i] =[start_i, end_i] indicates that a meeting is scheduled from day start_i​ to day end_i​ (both inclusive).

Your task is to count the days when the employee is available for work but has no scheduled meetings.

Note: The meetings may overlap.

https://leetcode.com/problems/count-days-without-meetings/description/


Constraints:

1 ≤ days ≤ 100000

1 ≤ meetings.length ≤ 1000

meetings[i].length == 2

1 ≤ meetings[i][0] ≤ meetings[i][1] ≤ days

def count_days(days, meetings):
    # initialize variable
    meetings.sort(key=lambda x: x[0])
    total = 0
    
    # allowed interval
    result = [meetings[0][:]]  
    
    # main
    # merge interval
    for i in range(1, len(meetings)):
        start2, end2 = meetings[i]
        if start2 <= result[-1][1]:
            result[-1][1] = max(result[-1][1], end2)
        else:
            result.append([start2, end2])
            
    # count total
    total = sum(end - start + 1 for start, end in result)
    
    return days - total

Remove Covered Intervals

Statement

Given an array of intervals, where each interval is represented as intervals[i] = [l_i, r_i) (indicating the range from l_i​ to r_i​, inclusive of l_i and exclusive of r_i, remove all intervals that are completely covered by another interval in the list. Return the count of intervals that remain after removing the covered ones.

Note: An interval [a, b) is considered covered by another interval [c, d) if and only if c <= a and b <= d.

https://leetcode.com/problems/remove-covered-intervals/

Constraints:

1 <= intervals.length <= 1000

intervals[i].length == 2

0 <= l_i < r_i <= 10**5

All the given intervals are unique.

def remove_covered_intervals(intervals):
    # initialize
    intervals.sort(key=lambda x: (x[0], -x[1]))
    result = [intervals[0][:]]
    
    # main
    for interval in intervals[1:]:
        start, end = interval
        
        # is cover
        last_start, last_end = result[-1]
        if start >= last_start and end <= last_end:
            continue
        else:
            result.append([start, end])
            
    return len(result)

