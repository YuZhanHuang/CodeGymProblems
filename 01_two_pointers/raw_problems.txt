Valid Palindrome

Statement

Write a function that takes a string, s, as an input and determines whether or not it is a palindrome.

Note: A palindrome is a word, phrase, or sequence of characters that reads the same backward as forward.

https://leetcode.com/problems/valid-palindrome/

constraints

1≤  s.length ≤ $2 \times 10^{15}$

The string s will not contain any white space and will only consist of ASCII characters.

def is_palindrome(s):
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1 
        right -= 1
      
    return True


Valid Palindrome II

Statement

Write a function that takes a string as input and checks whether it can be a valid palindrome by removing at most one character from it.

https://leetcode.com/problems/valid-palindrome-ii/

Constraints

1 ≤ string.length ≤ $10^5$

The string only consists of English letters

def valid_palindrome(s: str) -> bool:
    """
    判斷字串 s 是否能在最多移除一個字符後，成為回文串。
    回傳 True/False。
    """
    def is_pal(l: int, r: int) -> bool:
        """檢查 s[l..r] 區間是否為回文。"""
        while l < r:
            if s[l] != s[r]:
                return False
            l += 1
            r -= 1
        return True

    left, right = 0, len(s) - 1
    while left < right:
        if s[left] == s[right]:
            left += 1
            right -= 1
        else:
            # 嘗試跳過左邊或右邊的字符，只要任一成立即可
            return is_pal(left + 1, right) or is_pal(left, right - 1)
    return True


Reverse Words in a String


Statement

Given a sentence, reverse the order of its words without affecting the order of letters within a given word.

https://leetcode.com/problems/reverse-words-in-a-string/description/?utm_source=chatgpt.com

Constraints

Sentence contains English uppercase and lowercase letters, digits, and spaces.

1 ≤ sentence.length ≤ $10^4$

The order of the letters within a word is not to be reversed.

Note: The input string may contain leading or trailing spaces or multiple spaces between words. The returned string, however, should only have a single space separating each word. Do not include any extra spaces.


import re


def reverse_words(sentence):
    trimmed_sentence = re.sub(' +',' ',sentence.strip())
    reversed_sentence = list(trimmed_sentence[::-1])
    start, end, n = 0, 0, len(reversed_sentence)
    
    while start < n:
        while end < n and reversed_sentence[end] != ' ':
            end += 1
            
        str_rev(reversed_sentence, start, end - 1)
        start = end + 1
        end = start
    
    return ''.join(reversed_sentence)


def str_rev(_str, start_rev, end_rev):
    while start_rev < end_rev:
        _str[start_rev], _str[end_rev] = _str[end_rev], _str[start_rev]
        start_rev += 1

Minimum Number of Moves to Make Palindrome

Statement

Given a string s, return the minimum number of moves required to transform s into a palindrome. In each move, you can swap any two adjacent characters in s.

Note: The input string is guaranteed to be convertible into a palindrome.

https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/

Constraints:

1 ≤ s.length ≤ 2000

s consists of only lowercase English letters.

s is guaranteed to be converted into a palindrome in a finite number of moves.

def min_moves_to_make_palindrome(s: str) -> int:
    chars = list(s)
    n = len(chars)
    l, r = 0, n - 1
    moves = 0

    while l < r:
        # 如果本來就相等，就直接縮小範圍
        if chars[l] == chars[r]:
            l += 1
            r -= 1
            continue

        # 從右邊往左找，想找一個跟 chars[l] 一樣的字元
        k = r
        while k > l and chars[k] != chars[l]:
            k -= 1

        if k == l:
            # 情況 B：沒找到配對，chars[l] 是孤單字元，只能往中間推
            chars[l], chars[l + 1] = chars[l + 1], chars[l]
            moves += 1
        else:
            # 情況 A：在 k 找到配對，把 chars[k] 冒泡到 r
            while k < r:
                chars[k], chars[k + 1] = chars[k + 1], chars[k]
                k += 1
                moves += 1
            # 完成這一對的配對
            l += 1
            r -= 1

    return moves


Sum of Three Values

Statement

Given an array of integers, nums, and an integer value, target, determine if there are any three integers in nums whose sum is equal to the target, that is, nums[i] + nums[j] + nums[k] == target. Return True if three such integers exist in the array. Otherwise, return False.

Note: A valid triplet consists of elements with distinct indexes. This means, for the triplet nums[i], nums[j], and nums[k], 

i ≠ j, i ≠ k and j ≠ k.

https://leetcode.com/problems/3sum/

Constraints

3 ≤ nums.length ≤ 500

 $-10^3$ ≤ nums[i] ≤ $10^3$

$-10^4$ ≤ target ≤ $10^4$


def find_sum_of_three(nums, target):
   nums.sort()
   for i in range(len(nums)):
      low = i + 1
      high = len(nums) - 1

      while low < high:
         if target == nums[i] + nums[low] + nums[high]:
            return True
         elif target < nums[i] + nums[low] + nums[high]:
            high -= 1
         else:
            low += 1

   return False


Next Palindrome Using Same Digits

Statement

Given a string num_str representing a palindrome, the string only contains digits. Your task is to return the next possible palindrome using the same digits. The returned palindrome would be the next largest palindrome, meaning there can be more than one way to rearrange the digits to make a larger palindrome. Return an empty string if no greater palindrome can be made.

Consider the following example to understand the expected output for a given numeric string:

input string = "123321"

possible palindromes = "213312", "231132", "312213", "132231", "321123"

We should return the palindrome "132231" as it is greater than "123321" yet the smallest palindrome excluding the original palindrome.

https://leetcode.com/problems/next-palindrome-using-same-digits/

Constraints:

1 ≤ num.length ≤ $10^{5}$

num_str is a palindrome.


from typing import List


def next_permutation(chars: List[str]) -> bool:
    """
    對 chars 進行 in-place 的「下一個排列（字典序）」。
    若成功找到下一個排列，回傳 True；若已是最大排列，回傳 False。

    演算法步驟（標準 next_permutation）：
    1. 從右往左找第一個 i，使得 chars[i] < chars[i+1] （稱為 pivot）。
       若找不到，代表整個序列是非遞增（例如 3 2 2 1），沒有下一個排列，回傳 False。

    2. 再從右往左找第一個 j，使得 chars[j] > chars[i]。
       這個 j 是在 suffix 中，距離右側最近、且比 pivot 大的元素。

    3. 交換 chars[i], chars[j]。

    4. 將 i 之後的 suffix 反轉，使其變成最小的遞增序列。
    """
    n = len(chars)
    if n <= 1:
        return False

    # 1. 找 pivot：從右往左找第一個 chars[i] < chars[i+1]
    i = n - 2
    while i >= 0 and chars[i] >= chars[i + 1]:
        i -= 1

    if i < 0:
        # 已經是最大的排列
        return False

    # 2. 從右往左找第一個比 chars[i] 大的元素 j
    j = n - 1
    while j > i and chars[j] <= chars[i]:
        j -= 1

    # 3. 交換 pivot 與 j
    chars[i], chars[j] = chars[j], chars[i]

    # 4. 將 i 之後的 suffix 反轉
    left, right = i + 1, n - 1
    while left < right:
        chars[left], chars[right] = chars[right], chars[left]
        left += 1
        right -= 1

    return True


def next_palindrome_same_digits(num_str: str) -> str:
    """
    給定一個回文字串 num_str（只包含數字），回傳
    「用同樣 digits 可以組成的下一個較大的回文」。
    若不存在，回傳空字串 ""。
    """
    n = len(num_str)
    if n <= 1:
        # 單一字元本身就是唯一回文，沒有更大
        return ""

    # 左半邊 + （如果是奇數長度）中間字 + 右半邊（鏡像）
    half = list(num_str[: n // 2])
    mid = num_str[n // 2] if n % 2 == 1 else ""

    # 對左半邊做 next permutation
    if not next_permutation(half):
        # 左半邊已是最大排列，沒有更大的回文
        return ""

    # 組出新的回文：half + mid + reverse(half)
    new_left = "".join(half)
    new_right = new_left[::-1]
    return new_left + mid + new_right


Valid Word Abbreviation

Statement

Given a string word and an abbreviation abbr, return TRUE if the abbreviation matches the given string. Otherwise, return FALSE.

A certain word "calendar" can be abbreviated as follows:

"cal3ar" ("cal end ar" skipping three characters "end" from the word "calendar" still matches the provided abbreviation)

"c6r" ("c alenda r" skipping six characters "alenda" from the word "calendar" still matches the provided abbreviation)

The following are not valid abbreviations:

"c06r" (has leading zeroes)

"cale0ndar" (replaces an empty string)

"c24r" ("c al enda r" the replaced substrings are adjacent)

https://leetcode.com/problems/valid-word-abbreviation/

Constraints

1 ≤ word.length ≤ 20

word consists of only lowercase English letters.

1 ≤ abbr.length ≤ 10

abbr consists of lowercase English letters and digits.

All the integers in abbr will fit in a 32–bit integer.


def valid_word_abbreviation(word, abbr):
	i, j = 0, 0 

	while i < len(word) and j < len(abbr):
		if abbr[j].isdigit():
			if abbr[j] == '0' and (j == 0 or not abbr[j-1].isdigit()):
				return False
			num = 0
			while j < len(abbr) and abbr[j].isdigit():
				num = num * 10 + int(abbr[j])
				j += 1
			i += num
		else:
			if word[i] != abbr[j]:
				return False
			i += 1
			j += 1

	return i == len(word) and j == len(abbr)


Sort Color

Statement

Given an array, colors, which contains a combination of the following three elements:

0 (representing red)

1 (representing white)

2 (representing blue)

Sort the array in place so that the elements of the same color are adjacent, with the colors in the order of red, white, and blue.

Note: The function should only return the modified colors array.

https://leetcode.com/problems/sort-colors/?utm_source=chatgpt.com

Constraint

1 ≤ colors.length ≤ 300

colors[i] can only contain 0s, 1s, or 2s.


def sort_colors(colors):
    RED = 0
    WHITE = 1
    BLUE = 2
    red, white, blue = 0, 0, len(colors) - 1
    
    while white <= blue:
        if colors[white] == RED:
            if colors[red] != RED:
                colors[red], colors[white] = colors[white], colors[red]
            white += 1
            red += 1

        elif colors[white] == WHITE:
            white += 1
        else:
            if colors[blue] != BLUE:
                colors[white], colors[blue] = colors[blue], colors[white]
            blue -= 1

    return colors


Remove nth Node from End of List

Given a singly linked list, remove the nth node from the end of the list and return its head.

https://leetcode.com/problems/remove-nth-node-from-end-of-list/?utm_source=chatgpt.com

Constraint

The number of nodes in the list is k.

1 ≤ k ≤ $10^4$

$-10^3$ ≤ Node.value ≤ $10^3$

1 ≤  n ≤ Number of nodes in the list


# Definition for a Linked List node
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
from ds_v1.LinkedList.LinkedList import ListNode

def remove_nth_last_node(head: ListNode, n: int) -> ListNode:
    # 1) Dummy head simplifies removal of the real head
    dummy = ListNode(0)
    dummy.next = head

    # 2) Initialize two pointers both at dummy
    fast = dummy
    slow = dummy

    # 3) Move fast ahead by n+1 steps so gap between fast & slow is n
    for _ in range(n + 1):
        fast = fast.next

    # 4) Move both until fast hits the end
    while fast:
        fast = fast.next
        slow = slow.next

    # 5) slow.next is the node to remove
    slow.next = slow.next.next

    # 6) Return the (possibly new) head
    return dummy.next


Count Pairs Whose Sum is Less than Target


Statement

You are given a 0-indexed integer array, nums, of length n, and an integer target. Your task is to determine the number of distinct pairs of indexes $(i, j)$ such that:

$0 \le i \lt j \lt n$ (i.e., i comes before j in the array)

The sum of the elements of the indexes $(i, j)$, (i.e., $nums[i] + nums[j]$), is strictly less than the target.

https://leetcode.com/problems/two-sum-less-than-k/

Constraints:

n = nums.length

1 ≤ n ≤ 50

−50≤ nums[i], target ≤ 50


def count_pairs(nums, target):
    nums.sort()
    count = 0
    left, right = 0, len(nums) - 1

    while left < right:
        if nums[left] + nums[right] < target:
            # All pairs (left, left+1), (left, left+2), …, (left, right)
            # have sum < target, so add them all at once:
            count += (right - left)
            left += 1
        else:
            # Sum is too big, shrink from the right
            right -= 1

    return count

Lowest Common Ancestor of a Binary Tree III

Statement

You are given two nodes, p and q. The task is to return their lowest common ancestor (LCA). Both nodes have a reference to their parent node. The tree’s root is not provided; you must use the parent pointers to find the nodes’ common ancestor.

Note: The lowest common ancestor of two nodes, p and q, is the lowest node in the binary tree, with both p and q as descendants.

In a tree, a descendant of a node is any node reachable by following edges downward from that node, including the node itself.

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/

Constraints:

$-10^{4}$ ≤ Node.data  ≤ $10^{4}$

The number of nodes in the tree is in the range [2,500].

All Node.data are unique.

p != q

Both p and q are present in the tree.

def lowest_common_ancestor(p, q):
    """
    Walk two pointers up via parent links.  When one pointer
    reaches None, redirect it to the other start.  They will
    meet at the LCA in at most 2·h steps.
    Time: O(h), Space: O(1)
    """
    a, b = p, q
    while a is not b:
        # move up one step, or switch to the other node
        a = a.parent if a else q
        b = b.parent if b else p
    return a
